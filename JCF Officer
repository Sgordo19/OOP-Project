package Final_Project;

import java.util.Date;
import java.util.Scanner;
import java.io.ObjectOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Calendar;

public class JCF_Officer extends User {
    private String badgeNumber;
    private String policeStation;
    private Ticket[] currentTickets;  // Array to store current tickets
    private Driver[] drivers;         // Array to store drivers
    private int ticketCount = 0;      // Tracks number of tickets in the array
    private int driverCount = 0;      // Tracks number of drivers in the array
    private int maxTickets = 50;      // Maximum tickets the officer can manage
    private JCF_Officer officer = null;

    // Constructor
    public JCF_Officer() {
        super();  // Placeholder constructor to initialize User fields
        this.badgeNumber = "";
        this.policeStation = "";
        this.currentTickets = new Ticket[maxTickets];  // Default size for currentTickets
        this.drivers = new Driver[10]; // Default size for drivers
    }

    // Method to prompt for user information
    public void promptForUserInfo() {
        Scanner scanner = new Scanner(System.in);

        // Prompt for name
        System.out.println("Enter your full name:");
        this.name = scanner.nextLine();

        // Prompt for TRN
        System.out.println("Enter your TRN:");
        this.trn = scanner.nextLine();

        // Prompt for Date of Birth
        System.out.println("Enter your Date of Birth (MM/DD/YYYY):");
        this.dob = scanner.nextLine();

        // Prompt for Parish (with validation)
        this.parish = promptForParish();  // We assume promptForParish is defined

        // Prompt for contact number
        System.out.println("Enter your contact number:");
        this.contact_number = scanner.nextLine();
    }

    // Prompt for parish with validation (example: list of Jamaica's parishes)
    private String promptForParish() {
        String[] validParishes = {
            "1. Kingston", "2. St. Andrew", "3. St. Thomas", "4. Portland", "5. St. Mary", 
            "6. St. Ann", "7. Trelawny", "8. St. James", "9. Hanover", "10. Westmoreland", 
            "11. St. Elizabeth", "12. Manchester", "13. Clarendon", "14. St. Catherine"
        };

        Scanner scanner = new Scanner(System.in);
        String parish = "";

        while (true) {
            System.out.println("Select your Parish:");
            for (int i = 0; i < validParishes.length; i++) {
                System.out.println((i + 1) + ". " + validParishes[i]);
            }

            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume newline character

            if (choice >= 1 && choice <= validParishes.length) {
                parish = validParishes[choice - 1];
                break;
            } else {
                System.out.println("Invalid choice, please select a valid parish.");
            }
        }

        return parish;
    }

 // Method to view all outstanding tickets sorted by parish
    public void viewAllOutstandingTicketsSortedByParish() {
        // Get the parish from the user
        String selectedParish = promptForParish();

        System.out.println("\n--- Outstanding Tickets in " + selectedParish + " ---");
        boolean found = false;

        // Loop through the tickets and display information for the selected parish
        for (Ticket ticket : currentTickets) {
            if (ticket != null && ticket.getStatus().equalsIgnoreCase("Unpaid")
                    && ticket.getDriver().getParish().equalsIgnoreCase(selectedParish)) {
                System.out.println(ticket); // Ensure Ticket.toString() is implemented to print ticket details
                found = true;
            }
        }

        if (!found) {
            System.out.println("No outstanding tickets found in " + selectedParish + ".");
        }
    }

    // Method to prompt for parish with validation
    private String searchbyParish() {
        Scanner scanner = new Scanner(System.in);
        String[] validParishes = {
            "Kingston", "St. Andrew", "St. Thomas", "Portland", "St. Mary", 
            "St. Ann", "Trelawny", "St. James", "Hanover", "Westmoreland", 
            "St. Elizabeth", "Manchester", "Clarendon", "St. Catherine"
        };

        while (true) {
            System.out.println("Enter a parish from the following options:");
            for (String parish : validParishes) {
                System.out.print(parish + ", ");
            }
            System.out.println(); // Move to next line
            String input = scanner.nextLine();

            for (String parish : validParishes) {
                if (input.equalsIgnoreCase(parish)) {
                    return parish; // Valid parish found
                }
            }
            System.out.println("Invalid parish. Please try again.");
        }
    }

    // Prompt user and add a new ticket
    public void promptAndAddNewTicket() {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter Ticket Number:");
        String ticketNumber = scanner.nextLine();

        System.out.println("Enter Offence Code:");
        String offenceCode = scanner.nextLine();

        // Create a Fine object to handle fine calculation
        Fine fine = calculateFine(offenceCode);
        System.out.println("Fine Amount: " + fine.getFineAmount());

        System.out.println("Enter Offence Description:");
        String offenceDescription = scanner.nextLine();

        System.out.println("Enter Vehicle Plate Number:");
        String vehiclePlateNumber = scanner.nextLine();

        Driver driver = findDriverByPlate(vehiclePlateNumber); // Call the newly defined method
        if (driver == null) {
            System.out.println("Driver not found for the given vehicle plate number.");
            return;
        }

        // Ensure array has capacity
        if (ticketCount >= currentTickets.length) {
            System.out.println("Ticket array is full. Cannot add more tickets.");
            return;
        }

        // Use calculateDueDate method to determine the due date
        Date issueDate = new Date();
        Date dueDate = calculateDueDate();
        Date courtDate = null;  // You can set a default court date or leave it null
        String status = "Unpaid";

        // Create a ticket object
        Ticket ticket = new Ticket(ticketNumber, issueDate, offenceCode, offenceDescription, 
                fine.getFineAmount(), vehiclePlateNumber, driver, officer, status, dueDate, courtDate);

        // Display ticket info and prompt for confirmation
        boolean isConfirmed = viewAndConfirmTicket(ticket);
        if (isConfirmed) {
            currentTickets[ticketCount++] = ticket; // Add ticket to the array
            writeTicketsToFile();
            System.out.println("Ticket Added Successfully!");
        } else {
            System.out.println("Ticket entry was cancelled. Please re-enter the details.");
            promptAndAddNewTicket(); // Ask for details again if not confirmed
        }
    }

 // Method to check unpaid tickets past 21 days
    public void checkUnpaidTickets() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the Driver's TRN to check unpaid tickets:");
        String trn = scanner.nextLine();

        // Find the driver by TRN
        Driver driver = findDriverByTrn(trn);
        if (driver == null) {
            System.out.println("Driver not found.");
            return;
        }

        // Check for unpaid tickets that have passed the 21-day due date
        boolean hasUnpaidTickets = false;
        Date currentDate = new Date();

        for (Ticket ticket : currentTickets) {
            if (ticket != null 
                    && ticket.getDriver().getTrn().equals(trn) 
                    && ticket.getStatus().equalsIgnoreCase("Unpaid")) {
                if (ticket.getDueDate().before(currentDate)) {
                    long diffInMillies = Math.abs(currentDate.getTime() - ticket.getDueDate().getTime());
                    long diffInDays = diffInMillies / (24 * 60 * 60 * 1000);
                    if (diffInDays > 21) {
                        System.out.println("Ticket " + ticket.getTicketNumber() + " is unpaid and past the 21-day due date.");
                        hasUnpaidTickets = true;
                    }
                }
            }
        }

        if (!hasUnpaidTickets) {
            System.out.println("No unpaid tickets past the 21-day stipulation.");
        }
    }
    
 // Method to view outstanding tickets in a specific parish
    public void viewOutstandingTicketsInParish() {
        Scanner scanner = new Scanner(System.in);

        // Prompt user for the parish
        System.out.println("Enter the parish to view outstanding tickets:");
        String parish = scanner.nextLine();

        System.out.println("\n--- Outstanding Tickets in " + parish + " ---");

        // Initialize variables for tracking top offender
        Driver topOffender = null;
        int maxTickets = 0;

        // Count outstanding tickets per driver
        for (Driver driver : drivers) {
            if (driver != null && driver.getParish().equalsIgnoreCase(parish)) {
                int driverTicketCount = 0;

                for (Ticket ticket : currentTickets) {
                    if (ticket != null && ticket.getDriver().equals(driver) && ticket.getStatus().equalsIgnoreCase("Unpaid")) {
                        System.out.println(ticket); // Print ticket information
                        driverTicketCount++;
                    }
                }

                // Update the top offender if this driver has more tickets
                if (driverTicketCount > maxTickets) {
                    maxTickets = driverTicketCount;
                    topOffender = driver;
                }
            }
        }

        // Display results
        if (topOffender != null) {
            System.out.println("\n--- Top Offender in " + parish + " ---");
            System.out.println("Name: " + topOffender.getName());
            System.out.println("TRN: " + topOffender.getTrn());
            System.out.println("Address: " + topOffender.getParish());
            System.out.println("Contact: " + topOffender.getContactNumber());
            // Gender was not added //System.out.println("Gender: " + topOffender.gender());
            System.out.println("Number of Outstanding Tickets: " + maxTickets);
        } else {
            System.out.println("No outstanding tickets found in " + parish + ".");
        }
    }


 // Method to view all offenders with outstanding tickets
    public void viewOffendersWithOutstandingTickets() {
        System.out.println("\n--- Offenders with Outstanding Tickets ---");
        
        boolean found = false;
        for (Ticket ticket : currentTickets) {
            if (ticket != null && ticket.getStatus().equals("Unpaid")) {
                Driver driver = ticket.getDriver();
                System.out.println("Driver TRN: " + driver.getTrn());
                System.out.println("Driver Name: " + driver.getDriverName());
                System.out.println("Driver Address: " + driver.getParish());
                System.out.println("Ticket Number: " + ticket.getTicketNumber());
                System.out.println("Ticket Issue Date: " + ticket.getIssueDate());
                System.out.println("Ticket Due Date: " + ticket.getDueDate());
                System.out.println("Ticket Status: " + ticket.getStatus());
                System.out.println("------------------------------");
                found = true;
            }
        }
        
        if (!found) {
            System.out.println("No outstanding tickets found.");
        }
    }
    
 // Method to view all outstanding tickets in a specific parish
    public void viewOutstandingTicketsByParish() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter the Parish to view outstanding tickets:");
        String parish = scanner.nextLine();

        System.out.println("\n--- Outstanding Tickets in " + parish + " ---");

        boolean found = false;
        for (Ticket ticket : currentTickets) {
            if (ticket != null && ticket.getStatus().equals("Unpaid") && ticket.getDriver().getParish().equalsIgnoreCase(parish)) {
                Driver driver = ticket.getDriver();
                System.out.println("Ticket Number: " + ticket.getTicketNumber());
                System.out.println("Offence Code: " + ticket.getOffenceCode());
                System.out.println("Ticket Issue Date: " + ticket.getIssueDate());
                System.out.println("Ticket Due Date: " + ticket.getDueDate());
                System.out.println("Driver TRN: " + driver.getTrn());
                System.out.println("Driver Name: " + driver.getDriverName());
                System.out.println("Driver Address: " + driver.getParish());
                System.out.println("------------------------------");
                found = true;
            }
        }

        if (!found) {
            System.out.println("No outstanding tickets found in the specified parish.");
        }
    }


    // Find driver by TRN
    private Driver findDriverByTrn(String trn) {
        for (Driver driver : drivers) {
            if (driver != null && driver.getTrn().equals(trn)) {
                return driver;
            }
        }
        return null;
    }

    
    // Find driver by vehicle plate
    private Driver findDriverByPlate(String plateNumber) {
        for (int i = 0; i < driverCount; i++) {
            if (drivers[i] != null && drivers[i].getVehiclePlateNumber().equalsIgnoreCase(plateNumber)) {
                return drivers[i];
            }
        }
        return null;
    }

    // Calculate fine based on offence code and return a Fine object
    private Fine calculateFine(String offenceCode) {
        float fineAmount;
        String fineType = "";
        String fineDescription = "";

        switch (offenceCode) {
            case "1":
                fineAmount = 5000.0f;
                fineType = "Speeding";
                fineDescription = "Exceeding speed limit";
                break;
            case "2":
                fineAmount = 3000.0f;
                fineType = "Parking";
                fineDescription = "Illegal parking";
                break;
            default:
                fineAmount = 1000.0f;
                fineType = "General";
                fineDescription = "General offence";
                break;
        }

        return new Fine(fineAmount, fineType, fineDescription);
    }

    // Calculate due date, adding 30 days to the current date
    private Date calculateDueDate() {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DATE, 30);
        return calendar.getTime();
    }

    // Write tickets to file
    private void writeTicketsToFile() {
        try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("tickets.dat"))) {
            out.writeObject(currentTickets);
        } catch (IOException e) {
            System.out.println("Error writing to file: " + e.getMessage());
        }
    }

    // Display ticket details and prompt for confirmation
    private boolean viewAndConfirmTicket(Ticket ticket) {
        Scanner scanner = new Scanner(System.in);

        // Display the ticket details
        System.out.println("\n--- Ticket Information ---");
        System.out.println("Full Name: " + this.name);
        System.out.println("TRN: " + this.trn);
        System.out.println("Date of Birth: " + this.dob);
        System.out.println("Parish: " + this.parish);
        System.out.println("Contact Number: " + this.contact_number);
        System.out.println("Ticket Number: " + ticket.getTicketNumber());
        System.out.println("Offence Code: " + ticket.getOffenceCode());
        System.out.println("Fine Amount: " + ticket.getFineAmount());
        System.out.println("Offence Description: " + ticket.getOffenceDescription());
        System.out.println("Vehicle Plate Number: " + ticket.getVehiclePlateNumber());
        System.out.println("Driver: " + ticket.getDriver().getDriverName());
        System.out.println("Issue Date: " + ticket.getIssueDate());
        System.out.println("Due Date: " + ticket.getDueDate());

        // Ask if the ticket should be stored
        System.out.println("Do you want to store this ticket? (yes/no):");
        String confirmation = scanner.nextLine().toLowerCase();

        return confirmation.equals("yes");
    }

    // Main Menu to interact with the officer
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Create a JCF_Officer instance
        JCF_Officer officer = new JCF_Officer();
        
        // Prompt for user details (name, TRN, DOB, etc.)
        officer.promptForUserInfo(); 

        // Display collected user information
        System.out.println("Officer Information:");
        System.out.println("Name: " + officer.name);
        System.out.println("TRN: " + officer.trn);
        System.out.println("Date of Birth: " + officer.dob);
        System.out.println("Parish: " + officer.parish);
        System.out.println("Contact Number: " + officer.contact_number);

        // Simple menu for interacting with the officer
        while (true) {
            System.out.println("\n--- Menu ---");
            System.out.println("1. Add New Ticket");
            System.out.println("2. Retrieve Ticket");
            System.out.println("3. Delete Ticket");
            System.out.println("4. Exit");
            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume newline

            switch (choice) {
                case 1:
                    officer.promptAndAddNewTicket();
                    break;
                case 2:
                    // Method to retrieve ticket (to be implemented)
                    break;
                case 3:
                    // Method to delete ticket (to be implemented)
                    break;
                case 4:
                    System.exit(0);
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
}
